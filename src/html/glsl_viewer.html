<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="{{BASE_URI}}">
    <title>GLSL Preview</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #errorOutput {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1e1e1e;
            color: #f8f8f2;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.2rem;
            line-height: 1.5;
            white-space: pre-wrap;
            overflow-y: auto;
            padding: 20px;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
            display: none;
        }
    </style>
</head>
<body>
    <div id="errorOutput" style="display:none;"></div>
    <div id="shaderData" style="display: none;">{{SHADER_DATA}}</div>
    <canvas id="glCanvas"></canvas>
    <script type="module" src="main.js"></script>
    
    <script>
        /*
        try {
            const canvas = document.getElementById('glCanvas');
            const errorOutput = document.getElementById('errorOutput');
            const gl = canvas.getContext('webgl');

            if (!gl) {
                errorOutput.style.display = 'block';
                errorOutput.textContent = 'WebGL not supported';
                canvas.style.display = 'none';
                throw new Error('WebGL not supported');
            }

            // 从 Webview 中获取文件列表和行映射数据
            const fileList = JSON.parse(`{{FILE_LIST}}`);
            const lineMappings = JSON.parse(`{{LINE_MAPPINGS}}`);

            console.log("File List (Base64):", fileList);
            console.log("Line Mappings:", lineMappings);

            // Base64 解码工具
            function decodeBase64(encoded) {
                return atob(encoded);
            }

            // 合并 GLSL 文件内容
            function generateMergedGLSL(lineMappings, fileList) {
                return lineMappings
                    .map(mapping => {
                        const file = fileList[mapping.fileIndex];
                        const content = decodeBase64(file.fileContent);
                        const lines = content.split('\n');
                        return lines[mapping.localLine - 1];
                    })
                    .join('\n');
            }

            const fragmentShaderSource = generateMergedGLSL(lineMappings, fileList);
            console.log("Generated Fragment Shader Source:\n", fragmentShaderSource);

            // 根据全局行号查找文件路径和本地行号
            function findFileAndLine(globalLine) {
                if (globalLine > 0 && globalLine <= lineMappings.length) {
                    const mapping = lineMappings[globalLine - 1];
                    const fileInfo = fileList[mapping.fileIndex];
                    return {
                        filePath: decodeBase64(fileInfo.filePath),
                        localLine: mapping.localLine,
                    };
                }
                return null;
            }




            // 编译着色器并处理错误
            function compileShader(gl, source, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    let errorLog = gl.getShaderInfoLog(shader).replace(/[\u0000-\u001F\u007F-\u009F]+/g, '').trim();
                    console.error("Original Shader compilation error:", errorLog);

                    // 提取所有错误行号
                    const errorLineMatches = [...errorLog.matchAll(/ERROR:\s*\d+:(\d+)/g)];

                    // 替换错误日志中的全局行号为源文件的行号和文件路径
                    errorLineMatches.forEach(match => {
                        const globalLine = parseInt(match[1], 10);
                        const fileInfo = findFileAndLine(globalLine);

                        if (fileInfo) {
                            // 构造替换字符串
                            const originalLine = match[0]; // 原始错误信息中包含 "ERROR: ...:line"
                            const replacement = `<span style="color: red; font-weight: bold;">ERROR</span>` +
                                                `<span style="color: white;"> in</span>` +
                                                `<span style="color: yellow; font-family: monospace;"> ${fileInfo.filePath}</span>` +
                                                `<span style="color: white;"> : </span>` +
                                                `<span style="color: #00ccff; font-weight: bold;">${fileInfo.localLine}</span>`;

                            // 替换错误日志中的全局行号为文件路径+本地行号
                            errorLog = errorLog.replace(originalLine, replacement);
                        }
                    });

                    

                    throw new Error(`<span style="color: white; font-size: 1.5rem; font-weight: bold;">Shader compilation error:\n</span>${errorLog}`);
                }
                return shader;
            }

            // 顶点着色器代码
            const vertexShaderSource = `
                attribute vec4 a_position;
                void main() {
                    gl_Position = a_position;
                }
            `;

            // 编译并链接着色器程序
            const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                throw new Error(`Program linking error: ${gl.getProgramInfoLog(program)}`);
            }

            // 使用着色器程序
            gl.useProgram(program);

            // 设置顶点缓冲区并绘制
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 1, -1, -1, 1,
                -1, 1, 1, -1, 1, 1
            ]), gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

        } catch (error) {
            const errorOutput = document.getElementById('errorOutput');
            errorOutput.style.display = 'block';
            errorOutput.textContent = error.message || 'Unknown error occurred';

            // 使用 HTML 渲染错误日志
            errorOutput.innerHTML = `${errorOutput.textContent}`;

            console.error(error);


            
        }*/

    </script>
   
</body>
</html>
